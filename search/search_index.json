{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome! \ud83d\udc4b This documentation will guide you through setting up a Node.js project for building small to medium-scale RESTful APIs using Express.js. The aim is to provide a sustainable structure that simplifies complex projects into smaller, more reusable, and modular components. We will also focus on best practices and various ways to optimize workflow when working collaboratively.</p> <p> Node.js (or informally Node) is an open-source, cross-platform runtime environment that allows developers to run JavaScript on the server. Node provides an environment to run scripts server-side to produce dynamic web content for the client.</p> <p>Express.js is an unopinionated and fairly minimalist Node web framework that provides a robust set of features to develop production-ready web and mobile applications.</p>"},{"location":"#intended-users","title":"Intended Users","text":"<p>This documentation is targeted towards the following users:</p> <ul> <li>Beginner to intermediate developers who need to setup a backend for a personal project.</li> <li>Software development teams working on small or medium-sized web applications.</li> </ul>"},{"location":"#prerequisite-knowledge","title":"Prerequisite Knowledge","text":"<p>The documentation assumes the following:</p> <ul> <li>Working knowledge of JavaScript(ES6), HTML, CSS - you are expected to know how to write basic HTML and CSS to make a simple static website.</li> <li>Ability to use the terminal to run simple commands. </li> <li>Working knowledge of Node.js - you should be familiar with using a package manager such as <code>npm</code> or <code>yarn</code> to install Node.js packages or modules.</li> </ul>"},{"location":"#software-requirements","title":"Software Requirements","text":"<p>Before proceeding, ensure you have the following installed:</p> <ul> <li>Node.js v14.x or later</li> <li>Npm Package Manager v7.x or later</li> <li>Visual Studio Code</li> </ul> <p>Although the screenshots provided will be from VS Code, most of the instructions in this documentation are independent of your IDE. IDEs such as Visual Studio, WebStorm, and Atom are also viable alternatives.</p>"},{"location":"#procedures-overview","title":"Procedures Overview","text":"<p>The main sections of the documentation are summarized below:</p> <ul> <li>Elaboration on Project Structure</li> <li>Configuring Project for Collaboration</li> <li>Installing Express.js</li> <li>Adding Routes</li> <li>Middleware</li> </ul>"},{"location":"#typographical-conventions","title":"Typographical Conventions","text":"<ol> <li> <p>Some code snippets may have clickable numbers that can be useful  if you do not understand what a specific piece of code does.     See an example of this below:</p> <pre><code>const sum = (numbers) =&gt; {\nreturn numbers.reduce((a, b) =&gt; a + b, 0); // (1)\n};\n</code></pre> <ol> <li>Return the sum of the numbers in the list.</li> </ol> </li> <li> <p>Changes to a previously created files will be highlighted in yellow:</p> <pre><code>const sum = (numbers) =&gt; {\nconst multiplier = 2;\nreturn numbers.reduce((a, b) =&gt; multiplier * (a + b), 0);\n};\n</code></pre> </li> <li> <p>File names and npm packages will be formatted like: <code>somefile.js</code>.</p> </li> <li> <p>Instructions that require you to run a command in terminal will be formatted like:</p> <p>run some command in the terminal</p> </li> </ol>"},{"location":"#notes-and-warning-messages","title":"Notes and Warning Messages","text":"<p>Throughout the documentation, we will use message blocks to alert you to relevant information.  Each possible message block, from most important to least important:</p> <p>Danger</p> <p>Specifies actions that may cause an error or will cause the application to crash.</p> <p>Warning</p> <p>Specifies content that must be read before proceeding.</p> <p>Info</p> <p>Indicates additional information or tips.</p> <p>Success</p> <p>Indicates what success looks like.</p>"},{"location":"pages/configuration/","title":"Configuration","text":""},{"location":"pages/configuration/#overview","title":"Overview","text":"<p>In this section you will explore the use of ESLint and Prettier to standards for writing and formatting code.  As is common practice, you will use Prettier to handle formatting-related issues and ESLint for non-formatting (code quality) issues - see Prettier vs. Linters. This is particularly important for teams where collaboration is necessary. Using ESLint and Prettier provide many benefits, for instance1:</p> <ul> <li>Increased Code Consistency</li> <li>Better Codebase Coherence</li> <li>Detect Problematic Code Patterns</li> <li>Easier Code Formatting</li> </ul> <p>Indeed, these benefits are not just limited to development teams, they are equally useful for individuals working on personal projects. When potential employers look at your GitHub projects, one the first things they look at is the coding style.2</p> <p>You'll start by installing ESLint and Prettier, then walking through an example of how to start customizing the rules you want to adhere to.</p>"},{"location":"pages/configuration/#installation-initial-setup","title":"Installation &amp; Initial Setup","text":"<p>Before you are able to adding code style and formatter rules, you need to install a few packages using the terminal, as outlined below:</p> <p>Prerequisite</p> <p>You will use the <code>touch</code> command for creating files via the command line. <code>touch</code> is native on Linux and Unix systems. If you are on a Windows machine you can install <code>touch</code> globally by running the following command: </p> <p>npm install touch-cli -g</p> <ol> <li> <p>Install Prettier:</p> <p>npm install --save-dev prettier</p> </li> <li> <p>Install ESLint:</p> <p>npm install --save-dev eslint</p> </li> <li> <p>Install relevant ESLint dependencies:</p> <p>npm install --save-dev eslint-config-prettier eslint-plugin-prettier</p> </li> <li> <p>Create a <code>.prettierrc.js</code> file in the root of the directory:</p> <p>touch .prettierrc.js</p> </li> <li> <p>Open the <code>.prettierrc.js</code> file created above and add the following formatting rules:</p> <pre><code>module.exports = {\nsemi: true, // (1)\ntabWidth: 4, // (2)\nsingleQuote: true, // (3)\n};\n</code></pre> <ol> <li>Ensures that semicolons are added at the end of all statements.</li> <li>Specifies the number of spaces per indentation level to be 4.</li> <li>Specifies that single quotes  are used instead of double quotes</li> </ol> <p>The rules above are some basic settings suggested by Prettier. Click on the numbers on each line to see what each rule means. For a detailed overview of all the possible rules for Prettier, see Prettier Options.</p> </li> <li> <p>Create a <code>.eslint.js</code> file in the root of the directory:</p> <p>touch .eslint.js</p> </li> <li> <p>Open the <code>.eslint.js</code> file created above and add the following:</p> <pre><code>module.exports = {\nextends: ['prettier'], // (1)\nplugins: ['prettier'], // (2)\nrules: {\n'prettier/prettier': ['error'] // (3)\n},\n};\n</code></pre> <ol> <li>Enables the config from <code>eslint-config-prettier</code> (Step 3 \ud83d\udc46). Turns off some ESLint rules that conflict with Prettier.</li> <li>Registers <code>eslint-plugin-prettier</code> as plugin (Step 3 \ud83d\udc46). </li> <li>Enable a rule that allows you to use Prettier from within ESLint.</li> </ol> </li> </ol> <p>Development Dependencies</p> <p>In general, Node packages that are only required during development, should be installed using the  npm <code>--save-dev</code> flag, as shown in step 1 above.</p>"},{"location":"pages/configuration/#customization","title":"Customization","text":"<p>Prettier is highly opinionated which means you have much less fine-tuning control over formatting.  On the other hand, ESLint is much less opinionated and hence provides you with more control relating to code-quality standards. Thankfully, well-known companies such as Airbnb and Google have written their own code style guides - see Airbnb JavaScript Style Guide and Google Java Style Guide.  ESLint allows you to 'extend' or import the rules from either of the code-styles guides mentioned above.  It is worth noting that there is no hard and fast rule for establishing code-style rules and guidelines.  As an example, you will use the Airbnb JavaScript Style Guide as a base config and add a custom rule for illustrative purposes.</p> <ol> <li> <p>Install and save the necessary peer dependencies to use the Airbnb style guide:</p> <p>npm install --save-dev eslint-config-airbnb-base eslint-plugin-import</p> </li> <li> <p>Add <code>'airbnb-base'</code> to the <code>extends</code> array in the <code>.eslintrc.js</code> file:</p> <pre><code>module.exports = {\nextends: ['airbnb-base', 'prettier'], // (1)\nplugins: ['prettier'],\nrules: {\n'prettier/prettier': ['error'] },\n};\n</code></pre> <ol> <li>Imports preconfigured Airbnb style guide rules.</li> </ol> </li> <li> <p>Open the <code>package.json</code> file in the root directory and add a script called <code>lint</code> for running ESLint:</p> <pre><code>{\n...\n\"scripts\": {\n\"lint\": \"eslint . --fix --ext .js\"\n},\n...\n}\n</code></pre> <p>This script allows you to use <code>npm run lint</code> to run the ESLint on all JavaScript files in the project. It also silently fixes any fixable issues for you!</p> </li> <li> <p>Create a <code>server.js</code> file in the root of the directory:</p> <p>touch server.js</p> </li> <li> <p>Open <code>server.js</code> and log \"Hello World\" to the console:</p> <pre><code>console.log(\"Hello World\")\n</code></pre> </li> <li> <p>Run the <code>lint</code> script that you added in step 3 above:</p> <p>npm run lint</p> </li> <li> <p>Verify that the code is reformatted to be consistent with the rules you added to <code>.prettierrc.js</code>:</p> <p><pre><code>console.log('Hello World');\n</code></pre>    Notice, ESLint has automatically fixed some formatting issues for you.     ESLint changed the double quotes around Hello World to single quotes and added a semi-colon to the end of the statement.</p> <p>Warning</p> <p>You may have also noticed that ESLint warns you about the use of the <code>console</code>.  This is because, by default, the airbnb code style guide that we extended from has chosen to warn developers on the use on the console. ESLint makes it very easy to overwrite any code-style rules you want. To allow the use of the <code>console</code>, see steps 8 &amp; 9 below \ud83d\udc47.</p> </li> <li> <p>(Optional) Append a rule to the <code>.eslintrc.js</code> file that allows the use of the console:</p> <pre><code>module.exports = {\nextends: ['airbnb-base', 'prettier'], plugins: ['prettier'],\nrules: {\n'prettier/prettier': ['error'],\n'no-console': 'off' // (1)\n},\n};\n</code></pre> <ol> <li>Allow the use of <code>console</code> statements.</li> </ol> </li> <li> <p>(Optional) Rerun the <code>lint</code> script and verify that ESLint no longer shows a warning message: </p> <p>npm run lint</p> </li> </ol> <p>Congratulations \ud83d\udc4f</p> <p>This is all you need to do to start using ESLint and Prettier in your projects. For a more detailed list of the rules that use for customizing your code style, see ESLint Rules.</p> <p>Extensions for ESLint and Prettier</p> <p>Thankfully VS Code has extensions for both ESLint and Prettier:</p> <ul> <li>VS Code ESLint Extension: allows you you see ESLint errors while you code (even before running <code>npm run lint</code>)</li> <li>VS Code Prettier Extension:  allows you to format files automatically, everytime you save them.</li> </ul> <p>ESLint and Prettier also support other IDE's and editors: - ESLint Editor Integrations - Prettier Editor Integrations</p>"},{"location":"pages/configuration/#conclusion","title":"Conclusion","text":"<p>By the end of this section, you will have successfully learned the following:</p> <ul> <li> The benefits of using tools such as ESLint and Prettier.</li> <li> How to install and setup ESLint and Prettier.</li> <li> How to customize ESLint.</li> </ul> <p>Great job \ud83e\udd17. You can go ahead and click on the link below to move on to the next step:</p> <p>Installing Express</p> <ol> <li> <p>Why You Should Use ESLint, Prettier &amp; EditorConfig.\u00a0\u21a9</p> </li> <li> <p>Enforce your team\u2019s coding style with Prettier and TsLint.\u00a0\u21a9</p> </li> </ol>"},{"location":"pages/glossary/","title":"Glossary","text":"Term Definition API API stands for Application Programming Interface. It exposes some of an application's code intentionally for use by other applications. Backend The components of a website that handle and store data. They are not visible to the user. Code consistency The conformity or uniformity of the code, often achieved by following an established code style guide. Code style guide An opinionated guide of coding conventions, style, and best practices meant to ensure code consistency within a project. Can also be referred to as coding guidelines, coding standards, or coding conventions. Dependency Additional code required for the current application to run. Development stack The set of languages, libraries, IDEs and tools (including OS, database server and application server) used for application development. Endpoint One end of a communication channel where one system is interacting with another and performs some action. It is function made available through an API Entry point The point in a program that contains the function for starting the program. ES6 ES6 stands for ECMAScript 6, otherwise knowns as ECMAScript 2015. It is the most recent major version of the stadard for JavaScript. ESLint A popular linter for identifying and reporting problem patters found in ECMAScript or JavaScript code. HTTP request &amp; response HTTP stands for Hypertext Transfer Protocol. It is a standard for transferring information from the browser to the server (requests) and data from the server to the browser (responses). IDE IDE stands for integrated development environment. It is the software used for coding that integrates a text editor with additional tools. Linter A tool that analyzes code and flags programming errors, bugs, and stylistic errors. Localhost A default alias referring to the local computer or \"this computer's\" IP address. Package A file or directory that is described by a package.json file; typically exist as Node modules that can be imported and used in an application. Plugin An extension to an existing software that adds additional functionality. Prettier An opinionated code formatter that parses the code and reprints it according to the configured rules. RESTful API An API architectural style that uses HTTP requests to access and use data. Router An Express object that can store multiple endpoints. Used to organize routes and to create modular code. Routing The action of determining what information is display or what action is taken when a user navigates or triggers a specified endpoint or path. Route The path used in the URL to access endpoints. Runtime environment The environment where a program is executed. Server A computer or system that provides resources, data, services, or programs to other computers, known as clients, over a network."},{"location":"pages/installing-express/","title":"Installing Express","text":""},{"location":"pages/installing-express/#overview","title":"Overview","text":"<p>This section will focus on helping you set up an Express.js (or informally known as Express). It is a web application framework for Node.js that is free and open-source.  Express is used to provide server-side logic for web and mobile applications.</p>"},{"location":"pages/installing-express/#installation-steps-for-express","title":"Installation Steps for Express","text":"<p>In the introduction, you will have created a new project folder with all of the subfolders and subfolders required. First, we'll install express and any dependencies, and then walk you through how to create an Express server, so you can serve content to your front-end (browser).</p> <ol> <li> <p>Install <code>nodemon</code>:</p> <p>npm install --save-dev nodemon</p> </li> <li> <p>Install Express:</p> <p>npm install express</p> </li> <li> <p>Create a <code>src</code> folder in the root directory:</p> <p>mkdir src</p> </li> <li> <p>Create an <code>app.js</code> file in the <code>src</code> directory:</p> <p>touch src/app.js</p> </li> <li> <p>Open the <code>app.js</code> file created above and add the following code:</p> <pre><code>const express = require('express'); // (1)\nconst app = express(); // (2)\nconst port = 3000; // (3)\n\napp.get('/', (req, res) =&gt; { // (4)\nres.send('Hello World!');\n});\n\nmodule.exports = app; // (5)\n</code></pre> <ol> <li>This line of code will import the express module into your app.js entry point file.</li> <li>This line of code will create a new Express application.</li> <li>This line of code will store the number of the port that we will be using to connect to your localhost.</li> <li>The GET method route will allow our application to send the string \"Hello World!\" as a response when we connect to our localhost. You will be learning more about HTTP methods like GET in a later section.</li> <li>Export the Express application so that <code>server.js</code> can use it.</li> </ol> </li> <li> <p>Create an <code>server.js</code> file in the root directory:</p> <p>touch server.js</p> </li> <li> <p>Open the <code>server.js</code> file created above and add the following code:</p> <pre><code>const app = require('./src/app'); // (1)\n\nconst port = 3000; // (2)\n\napp.listen(port, () =&gt; { // (3)\nconsole.log(`\ud83d\ude80 Server started successfully, listening on port ${port}: http://localhost:${port}`);\n});\n</code></pre> <ol> <li>Import instance of Express Application created in <code>src/app.js</code>.</li> <li>Specify port number for server to listen on.</li> <li>Start server and listen on specified port.</li> </ol> </li> </ol>"},{"location":"pages/installing-express/#start-express-server","title":"Start Express Server","text":"<p>In this last section, you will learn how to run your Express server on your localhost. You will be able to see the string \"Hello World\" from earlier in your internet browser by visiting your localhost:3000.</p> <ol> <li> <p>Open the <code>package.json</code> file in the root directory and add a script to start Express:</p> <pre><code>{\n...\n\"scripts\": {\n\"start\": \"nodemon server.js\", // (1)\n\"lint\": \"eslint . --fix --ext .js\"\n},\n...\n}\n</code></pre> <ol> <li>This script allows you to use <code>npm run start</code> or <code>npm start</code> to start the Express server.</li> </ol> </li> <li> <p>Run the script create above to start the Express server:</p> <p>npm start</p> </li> <li> <p>Open your internet browser of choice and type in the URL for the Express server:</p> <p>localhost:3000</p> </li> </ol> <p>Success</p> <p>Once the page loads, you should see \"Hello World!\" in your browser. This means that you have successfully installed and created your first working server!</p>"},{"location":"pages/installing-express/#conclusion","title":"Conclusion","text":"<p>By the end of this section, you will have successfully learned the following:</p> <ul> <li> How to install Express</li> <li> How to create a working Express server on your localhost</li> </ul> <p>Great job \ud83e\udd17. You can go ahead and click on the link below to move on to the next step:</p> <p>Adding Routes</p>"},{"location":"pages/middleware/","title":"Middleware","text":""},{"location":"pages/middleware/#overview","title":"Overview","text":"<p>When a server receives a <code>HTTP</code> request from the client (browser) it usually processes it and eventually returns some information to client via a <code>HTTP</code> response. This is known as the application\u2019s request-response cycle. For a more in-depth understanding on request-response cycles, see The Request/Response Cycle of the Web.  In Express, middleware are functions (or logic) that provide a convenient mechanism to handle <code>HTTP</code> requests entering your application.  Middleware functions can be chained together to perform a series of logic, one after the other. The last middleware function will typically end the request-response cycle by returning a response to the client.</p> <p>There are five(5) main categories of middleware that express supports, namely:</p> <ul> <li>Built-in</li> <li>Third-party </li> <li>Error-handling</li> <li>Application-level</li> <li>Router-level</li> </ul> <p>In this section you'll walk through an example of adding several middleware to Express.</p>"},{"location":"pages/middleware/#using-middleware-in-express","title":"Using Middleware in Express","text":"<ol> <li> <p>Add into <code>src/app.js</code> a built-in middleware in that parses incoming requests that contain JSON data:</p> <pre><code>const express = require('express');\nconst router = express.Router();\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\n...\n\nmodule.exports = app;\n</code></pre> <p>This allows Express to handle html form data that are sent to the server via a <code>POST</code>.</p> </li> <li> <p>Install Helmet:</p> <p>npm install helmet</p> </li> <li> <p>Import <code>helmet</code> in <code>src/app.js</code>:     <pre><code>const express = require('express');\nconst router = express.Router();\nconst helmet = require('helmet');\n...\n\nmodule.exports = app;\n</code></pre></p> </li> <li> <p>Load <code>helmet</code> middleware:</p> <pre><code>const express = require('express');\nconst router = express.Router();\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(helmet());\n...\n\nmodule.exports = app;\n</code></pre> <p>Helmet is a third-party middleware that adds some default protection to your Express application by setting various <code>HTTP</code> headers. </p> </li> <li> <p>Define a custom error-handling middleware function:</p> <pre><code>const express = require('express');\nconst router = express.Router();\n\nconst app = express();\n\n// Middleware\napp.use(express.json());\napp.use(helmet());\napp.use(function (err, req, res, next) {\n//Extra logic for handling errors\nres.status(500).send('Something broke!');\n});\n...\n\nmodule.exports = app;\n</code></pre> <p>Error-handling middleware allows you to catch and process errors that occur within the application.</p> </li> </ol> <p>Congratulations \ud83d\udc4f</p> <p>That is for middleware! If it interests you, there is a lot more to middleware provided in the Express Middleware Documentation.</p>"},{"location":"pages/middleware/#conclusion","title":"Conclusion","text":"<p>By the end of this section, you will have successfully learned the following:</p> <ul> <li> That they are different types of middleware that Express supports</li> <li> How to add built-in, third-party, and error-handling middleware to Express applications.</li> </ul> <p>Great job \ud83e\udd17. Check out the next page if you've had any issues getting the project to work:</p> <p>Troubleshooting</p>"},{"location":"pages/possible-project-structure/","title":"Possible project structure","text":"<p>Possible project structure. This is not written in stone, MVC and other architecture are often highly opinionated. <pre><code>|-- project-name              # Root Directory\n|-- docs/                 # Documentation\n|-- public/               # Publicly Accessible Assets\n|   |-- images/\n    |   |-- js/               # Client-side JavaScript\n|   |-- styles/           # CSS Stylesheets   \n|-- src/\n    |   |-- app.js            # Application Entry Point\n|   |-- api/\n    |   |   |-- controllers/  # Request Managers\n|   |   |-- middleware/   # Intermediary b/w Client Request &amp; Server Response\n|   |   |-- routes/       # API Endpoints (URIs)\n|   |-- config/           # Configuration/Settings Files\n|   |-- db/               # Mock Database or Connection to Database\n|   |-- models/           # Database Models\n|   |-- services/         # Services Layer for Business Logic (Talks to Database)\n|   |-- utils/            # Miscellaneous Helper Functions\n|   |-- views/            # Static Template Files (EJS, Pug, or Mustache)\n|-- test/                 # Test Suite   \n|-- .env                  # Environment Variables\n|-- .eslintignore\n    |-- .eslintrc.js          # Linting Rules\n|-- .gitignore            # Files/Directory Git Should Ignore \n|-- .prettierignore   |-- .prettierrc.js        # Code Formatting Rules\n|-- package.json          # Metadata and Package List\n|-- README.md\n    |-- server.js             # Application Server \n</code></pre></p>"},{"location":"pages/project-structure/","title":"Project Structure","text":""},{"location":"pages/project-structure/#overview","title":"Overview","text":"<p>When working on a project, it is important to have a clear project structure. Although the importance of having a project structure may seem insignificant when working on a small project, programmers and engineers will often collaborate with each other to write thousands of lines of code. It would be pure chaos if there was no defined project structure to keep all of your code organized. On top of this, troubleshooting issues and implementing new features would be a nightmare.</p> <p>Model-View-Controller (MVC)</p> <p>An MVC is a software design pattern that is used to divide all related program logic into three core logical components called the Model, View, and Controller. The Controller is used to control what View is displayed while using the Model to provide data for the View to render.</p> <p>In this guide we will be using this project structure to guide you towards creating a small to medium-sized project. As your project grows larger, you will want to modify and personalize your project as you find is necessary.</p> <p>Please refer to the example below to see the overview of the project structure:</p> <pre><code>    |-- project-name              # Root Directory\n|-- src/                  # Application Programming Interfaces\n|   |-- api/              # API Endpoints (URIs)\n|   |   |-- routes/       # API Endpoints (URIs)\n|   |   |   |--app.js     # Entry Point File\n|-- node_modules/         # Downloaded Libraries\n|-- .eslintrc.js          # Linting Rules \n|-- .prettierrc.js        # Code Formatting Rules\n|-- package.json          # Metadata and Package List\n|-- package-lock.json     # Version Number for Dependencies\n|-- server.js             # Server File\n</code></pre>"},{"location":"pages/project-structure/#create-a-subfolder","title":"Create a Subfolder","text":"<p>Before we get started, you will want to create a folder where you will store your new express project. This folder is called the root folder (also known as root directory or root). In this section, you will be creating the subfolder structure for your project. Folders created inside of the root folder are called subfolders.</p> <p>Go ahead and up your project in Visual Studio Code.</p> <ol> <li> <p>Type the command below in the Terminal to create a docs folder.</p> <p>mkdir src</p> </li> </ol>"},{"location":"pages/project-structure/#create-nested-subfolders","title":"Create Nested Subfolders","text":"<p>After you have created your first subfolder in the project, we will be creating more folders inside of the <code>src</code> folder. The newly created folders are called nested subfolders. The source (src) folder will contain all of the files needed to build your project.</p> <ol> <li> <p>Type the command below to move into your <code>src</code> directory.</p> <p>cd src</p> </li> <li> <p>Type the command below to create an <code>api</code> folder inside the <code>src</code>.</p> <p>mkdir api</p> </li> <li> <p>Type the command below to move into your <code>api</code> directory.</p> <p>cd api</p> </li> <li> <p>Type the command below to create <code>routes</code> folder inside the <code>api</code> folder.</p> <p>mkdir routes</p> <p>Medium to Large Projects</p> <p>Here is an example of a medium to larger scaled project. You can choose what kinds of folders will be required for your personalized project.</p> <pre><code>|-- project-name\n    |-- node_modules/\n    |-- public/\n    |   |-- images/\n    |   |-- js/\n    |   |-- styles/\n    |-- src/\n    |   |-- api/\n    |   |   |-- controllers/\n    |   |   |-- middleware/\n    |   |   |-- routes/\n    |   |-- config/\n    |   |-- db/\n    |   |-- models/\n    |   |-- services/\n    |   |-- utils/\n    |   |-- views/\n    |-- .eslintrc.js\n    |-- .prettierrc.js\n    |-- package.json\n    |-- package-lock.json\n</code></pre> <p>Test Subfolder Recommendation</p> <p>Another folder that we highly recommend creating is a test subfolder. As your projects get bigger, you will find that testing your applications will make it easier to maintain your code. Although it is not always necessary for smaller projects, it is considered good practice to use test suites to test your application.</p> </li> </ol>"},{"location":"pages/project-structure/#conclusion","title":"Conclusion","text":"<p>By the end of this section, you will have successfully learned the following:</p> <ul> <li> Why project structure is important</li> <li> How to organize the subfolders</li> <li> How to organize nested subfolders</li> </ul> <p>Congratulations! \ud83c\udf89 You can go ahead and click on the link below to learn more about how to configure your project:</p> <p>Configuration</p>"},{"location":"pages/routes/","title":"Routes & Routers","text":""},{"location":"pages/routes/#overview","title":"Overview","text":"<p>In this section, we will walk you through how to set up your first routes for your Express server. Afterwards, we will see how we can clean up the code using routers.</p> <p>Routes &amp; HTTP Requests</p> <p>In Express, a route interprets the HTTP request method made to the server.</p> <p>Routing is the action of determining what information is display or what action is taken when a user navigates or triggers a specified endpoint or path.</p> <p>A simple route comprises the following components</p> <ul> <li><code>app</code> : the instance of Express that you have created in Getting Started</li> <li><code>method</code>:  the Express route method corresponding to HTTP requests (eg. <code>get</code>, <code>post</code>, or <code>put</code>)</li> <li><code>path</code>: the defined endpoint of the request</li> <li><code>handler</code>: the function that is called when the route is hit</li> </ul> <p>Handler functions</p> <p>The handler will often be an anonymous function written as either a regular function or an arrow function. You may see more than one handler function per route in more complex routes.</p>"},{"location":"pages/routes/#setting-up-routes","title":"Setting up routes","text":"<p>We will cover the 2 most generic route methods: <code>GET</code> and <code>POST</code>. </p> <p>GET &amp; POST</p> <p>The <code>GET</code> method is used to request data from a server. The <code>POST</code> method is used to send data to create date or update data on a server. 1</p> <p>We left off in Installing Express with one route already set up to the root directory (<code>'/'</code>) from <code>src/app.js</code>.  The handler for this route is an anonymous function that takes in two parameters.  The first parameter represents the HTTP request object (often written as <code>request</code> or <code>req</code>) and the second parameter is the response object (written as <code>response</code> or <code>res</code>).</p> <p>A response method is called in the handler to terminate the request-response cycle.</p> <pre><code>const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) =&gt; { // (1)\nres.send('Hello World!'); // (2)\n});\nmodule.exports = app;\n</code></pre> <ol> <li><code>'/'</code> (forward slash) is your root directory.</li> <li><code>res.send()</code> can send back various types of content.</li> </ol> <p>Info</p> <p>Remember you can click on the numbers at the end of a line of code for extra information about the specific examples used.</p>"},{"location":"pages/routes/#returning-a-static-webpage-using-get","title":"Returning a Static Webpage Using GET","text":"<p>As an example, let's create a route to display a contact page in the form of a static HTML page.</p> <ol> <li> <p>Start with the route method and insert the path for your Express server to listen for.     <pre><code>app.get('/contact');\n</code></pre></p> </li> <li> <p>Insert an empty handler that has the parameters for the request and response objects <pre><code>app.get('/contact', (req, res) =&gt; { });\n</code></pre></p> </li> <li> <p>Insert the action you want to perform into the handler function:</p> <pre><code>app.get('/contact', (req, res) =&gt; {\nres.sendFile('contact.html'); // (1)\n});\n</code></pre> <ol> <li>Use <code>res.sendFile()</code> to serve a static HTML page.</li> </ol> </li> </ol>"},{"location":"pages/routes/#sending-data-using-post","title":"Sending Data Using POST","text":"<p>Suppose you have a form on your contact page for users to submit a message. You would use a POST request so that you can retrieve the submitted data and store it somewhere.</p> <p>For this example, we will pretend that the server is receiving data from the following form. <pre><code>&lt;form method=\"POST\" action=\"/contact\"&gt;\n  &lt;input type=\"email\" name=\"email\"&gt;\n  &lt;input type=\"text\" name=\"message\"&gt;\n  &lt;input type=\"submit\"&gt;\n&lt;/form&gt;\n</code></pre></p> <p>Action &amp; Name Attributes</p> <p>The action attribute must match the path that will match the route path where we insert the handler logic. The name attribute for each input will become the key/property of the object that the form will send to your server.</p> <ol> <li> <p>Start with the route method and insert the path for your Express server to listen for.     <pre><code>app.post('/contact');\n</code></pre>     Note that you can use the same path with different methods to perform different actions.</p> </li> <li> <p>Insert an empty handler that has the parameters for the request and response objects <pre><code>app.post('/contact', (req, res) =&gt; { });\n</code></pre></p> </li> <li> <p>Insert the action you want to perform into the handler function.</p> <pre><code>app.post('/contact', (req, res) =&gt; {\nconst email = req.body.email; // (1)\nconst message = req.body.message;\n// code to process the form data\nres.redirect('/confirmation'); // (2)\n});\n</code></pre> <ol> <li>req.body` it the object containing the input names and values from the form that was posted.</li> <li>Use <code>res.redirect()</code> to redirect your user to another page/route to end your handler function.</li> </ol> </li> </ol> <p>Success</p> <p>At this point, you have the tools to set up many routes in your <code>app.js. Next we will cover how to refactor your routes so</code>app.js` is more manageable.</p> <pre><code>const express = require('express');\nconst app = express();\n\napp.get('/', (req, res) =&gt; {\nres.send('Hello World!');\n})\n\napp.get('/contact', (req, res) =&gt; {\nres.sendFile('contact.html');\n});\n\napp.post('/contact', (req, res) =&gt; {\nconst email = req.body.email;\nconst message = req.body.message;\n// code to process the form data\nres.redirect('/confirmation');\n});\n\napp.get('/reviews', (req, res) =&gt; {\nres.sendFile('reviews.html');\n});\n\napp.get('/reviews/add', (req, res) =&gt; { // (1)\n// code to add a review\nres.redirect('/reviews');\n});\n\napp.get('/reviews/delete', (req, res) =&gt; {\n// code to delete a review\nres.redirect('/reviews');\n});\n\nmodule.exports = app;\n</code></pre> <ol> <li>Note that you can use multi-level paths as well.</li> </ol>"},{"location":"pages/routes/#setting-up-routers","title":"Setting up Routers","text":"<p>As the scope of your project grows or scales, you may find the need to organize your routes for ease of maintenance. Express provides a class to help achieve this called a Router.</p> <p>If you had several related endpoints, it would be more manageable to organize these related routes into their own file. The Express router can help you achieve this by allowing you to export this grouping into another file (in our case <code>app.js</code>). This file acts as a main hub directing requests to the appropriate endpoints.</p>"},{"location":"pages/routes/#router-example","title":"Router Example","text":"<p>We will add onto our previous example with the contact page routes. At the moment, these routes are in <code>src/app.js</code>. We want to move the contact routes to their own file for better organization.</p> <ol> <li> <p>Create a new JavaScript File called <code>contactRoute.js</code> in <code>src/api/routes</code>.     You can technically make this file anywhere you wish in your project but for this example, we will use this project structure.</p> </li> <li> <p>Require Express into <code>contactRoute.js</code> and create a new instance of the Router class by storing it to a new variable (<code>router</code>).</p> <pre><code>const express = require('express'); // (1)\nconst router = express.Router(); // (2)\n</code></pre> <ol> <li>Import the Express module so we can access its properties</li> <li>Make a new instance of the built-in Router class that will hold the routes we assign to it.</li> </ol> </li> <li> <p>Cut and paste the two contact routes from <code>app.js</code> into the <code>contactRoute.js</code> file.     <pre><code>const express = require('express');\nconst router = express.Router();\n\napp.get('/contact', (req, res) =&gt; {\nres.sendFile('contact.html');\n});\napp.post('/contact', function(req, res) {\nconst email = req.body.email;\nconst message = req.body.message;\n// code to process the form data\nres.redirect('/confirmation');\n});\n</code></pre></p> </li> <li> <p>Change <code>app</code> to <code>router</code> so that the routes are now associated to this router instance.     We can remove 'contact' from our path now as we will be setting the 'contact' path in <code>app.js</code>.     <pre><code>const express = require('express');\nconst router = express.Router();\n\nrouter.get('/', function(req, res) {\nres.sendFile('contact.html');\n});\n\nrouter.post('/', function(req, res) {\nconst email = req.body.email;\nconst message = req.body.message;\n// code to process the form data\nres.redirect('/confirmation');\n});\n</code></pre></p> </li> <li> <p>Add an export to the end of the file so we can access this router and its associated routes from other files.</p> <pre><code>const express = require('express');\nconst router = express.Router();\n\nrouter.get('/contact', function(req, res) {\nres.sendFile('contact.html');\n});\n\nrouter.post('/contact', function(req, res) {\nconst email = req.body.email;\nconst message = req.body.message;\n// code to process the form data\nres.redirect('/confirmation');\n});\n\nmodule.exports = router; // (1)\n</code></pre> <ol> <li>Your routes have been set to this variable so we only have to export the <code>router</code> and not the individual routes.</li> </ol> </li> <li> <p>Import the contact router into <code>app.js</code>.</p> <pre><code>const express = require('express');\nconst app = express();\n\nconst contactRoute = require('api/routes/contactRoute'); // (1)\nmodule.exports = app;\n</code></pre> <ol> <li>Make sure you are requiring your router from wherever you have placed your <code>contactRoute.js</code> in your project.</li> </ol> </li> <li> <p>Use <code>app.use()</code> to load the router into the Express app.     Paths that start with <code>/contact</code> will now be sent to <code>contactRoute.js</code> for further routing.</p> <pre><code>const express = require('express');\nconst app = express();\n\nconst contactRoute = require('api/routes/contactRoute');\n\napp.use('/contact', contactRoute); // (1)\nmodule.exports = app;\n</code></pre> <ol> <li><code>app.use()</code> tells Express what functions you want to associate with the path in the first parameter.</li> </ol> </li> </ol> <p>Success</p> <p>You can have many router files in your project that you can import into another file for use. This will keep your files a mangeable size for readability.  </p> <pre><code>const express = require('express');\nconst app = express();\n\n// Routes\nconst indexRoute = require('api/routes/indexRoute');\nconst contactRoute = require('api/routes/contactRoute');\nconst authRoute = require('api/routes/authRoute');\nconst reviewsRoute = require('api/routes/reviewsRoute');\n\n// Route Matchers\napp.use('/', indexRoute);\napp.use('/contact', contactRoute);\napp.use('/auth', authRoute);\napp.use('/reviews', reviewsRoute); // (1)\n\nmodule.exports = app;\n</code></pre> <ol> <li>The <code>reviews/add</code> and <code>reviews/delete</code> paths now exist in a <code>reviewRoute.js</code> file as <code>/add</code> and <code>/delete</code>.</li> </ol>"},{"location":"pages/routes/#conclusion","title":"Conclusion","text":"<p>By the end of this section, you will have successfully learned the following:</p> <ul> <li> How to write a route to set the desired response to different HTTP requests</li> <li> How to use the Express Router class to group routes</li> <li> How to export and import the router for use in separate file</li> </ul> <p>Great job \ud83e\udd17. You can go ahead and click on the link below to move on to the next step:</p> <p>Using Middleware</p> <ol> <li> <p>HTTP Request Methods.\u00a0\u21a9</p> </li> </ol>"},{"location":"pages/snippets/","title":"Snippets","text":"<p>Possible project structure. This is not written in stone, MVC and other architecture are often highly opinionated. <pre><code>|-- project-name              # Root Directory\n|-- docs/                 # Documentation\n|-- public/               # Publicly Accessible Assets\n|   |-- images/\n    |   |-- js/               # Client-side JavaScript\n|   |-- styles/           # CSS Stylesheets   \n|-- src/\n    |   |-- app.js            # Application Entry Point\n|   |-- api/\n    |   |   |-- controllers/  # Request Managers\n|   |   |-- middleware/   # Intermediary b/w Client Request &amp; Server Response\n|   |   |-- routes/       # API Endpoints (URIs)\n|   |-- config/           # Configuration/Settings Files\n|   |-- db/               # Mock Database or Connection to Database\n|   |-- models/           # Database Models\n|   |-- services/         # Services Layer for Business Logic (Talks to Database)\n|   |-- utils/            # Miscellaneous Helper Functions\n|   |-- views/            # Static Template Files (EJS, Pug, or Mustache)\n|-- test/                 # Test Suite   \n|-- .env                  # Environment Variables\n|-- .eslintignore\n    |-- .eslintrc.js          # Linting Rules\n|-- .gitignore            # Files/Directory Git Should Ignore \n|-- .prettierignore   |-- .prettierrc.js        # Code Formatting Rules\n|-- package.json          # Metadata and Package List\n|-- README.md\n    |-- server.js             # Application Server \n</code></pre></p> <pre><code>/** .eslintrc.js */\n\nmodule.exports = {\nextends: 'airbnb-base', // (1)\nenv: { // (2)\nbrowser: true,\ncommonjs: true,\nnode: true,\nes6: true,\njquery: true,\n},\nrules: {\nindent: ['error', 4], // (3)\n'linebreak-style': 0, // (4)\n'max-len': ['error', { code: 120 }], // (5)\n'max-lines-per-function': ['error', { max: 35, skipComments: true }], // (6)\n'max-nested-callbacks': ['error', 2], // (7)\n'no-console': 'off', // (8)\n},\n};\n</code></pre> <ol> <li>Inherit all rules from airbnb code styleguide.</li> <li>Environments that provide predefined global variables - see ESLint Environments for a complete list of supported environments.</li> <li>Enforces consistent indentation (4 spaces).</li> <li>Enforces consistent linebreak style.</li> <li>Enforces a maximum line length of 120 characters.</li> <li>Enforces a maximum function length of 35 lines.</li> <li>Enforces a maximum depth or 3 that callbacks can be nested. A common pitfall that is easy to fall into is nesting callbacks, which makes code more difficult to read the deeper the callbacks are nested.</li> <li>Allows the use of console.</li> </ol> <pre><code>/** .prettierrc.js */\n\nmodule.exports = {\ntrailingComma: \"es5\",\ntabWidth: 4,\nsemi: true,\nsingleQuote: true,\n};\n</code></pre> <pre><code>/** /src/app.js */\n\nconst express = require('express'); // (1)\n\nconst app = express(); // (2)\n\napp.get('/', (req, res) =&gt; { // (3)\nres.send('Hello World'); // (4)\n});\n\nmodule.exports = app;\n</code></pre> <ol> <li>Import Express module</li> <li>Create Express application </li> <li>Handle <code>GET</code> request made for the root URL. <code>req</code> is the incoming request and <code>res</code> is used to send back the desired HTTP response.</li> <li>Return a message of 'Hello World' in response to the HTTP request.</li> </ol> <p>Note, express supports methods that correspond to each HTTP request method (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, etc. ). For a refresher on the different HTTP request methods, see here.</p> <pre><code>/** server.js */\n\nconst app = require('./src/app'); // (1)\n\nconst port = process.env.PORT || 3000; // (2)\n\napp.listen(port, () =&gt; { // (3)\nconsole.log(`\ud83d\ude80 Server started successfully, listening on port ${port}`);\n});\n</code></pre> <ol> <li>Import instance of Express Application created in <code>/src/app.js</code>.</li> <li>Specify port number for server to listen on. </li> <li>Start server and listen on specified port.</li> </ol>"},{"location":"pages/troubleshooting/","title":"Troubleshooting","text":"Symptoms Probable Cause Action Unable to load the localhost page Your URL does not match your port number. Double check what port you have set in <code>server.js</code> and if your browser URL is <code>localhost:PORT</code> with <code>PORT</code> being the number you have set. You forgot to tell the Express app to listen to a port number. Make sure you have <code>app.listen(port, () =&gt; {})</code> in  <code>server.js</code> to configure which port you want Express to watch. You have another app running on the same port. Close any additional servers that might be running. Only one app per port is possible. ESLint warns you about the use of the console You have not configured ESLint to accept <code>console.log</code>. Make sure you have <code>rules: {'no-console': 'off' },</code> set in <code>.eslintrc.js</code> as directed in Eslint Customization \"TypeError: app.listen is not a function\" or similar You forgot to export one of your modules (ie. app or router). Make sure you have <code>module.exports = router;</code> at the end of your router files and <code>module.exports = app;</code> where you created your new Express app. \"Error: Cannot find module '&lt;NAME&gt;'\" You're requiring the module from the wrong path. Double check the path in the <code>require(PATH)</code> is pointing to the correct location. localhost is loading indefinitely You forgot to include (or you are not hitting) a response method. Make sure the handler function includes a response method to end the HTTP request-response cycle."}]}